**依赖倒置原则**

#### 定义

> 是指设计代码架构时，高层模块不应该依赖于底层模块，二者都应该依赖于抽象。抽象不依赖于细节，细节依赖于抽象。

#### 模拟场景

​		在互联网的营销活动中，经常为了拉新客户和促活，会做一些抽奖活动。这些抽奖活动规则会随着业务的不断发展而调整，如随机抽奖、权重抽奖等，其中，权重值用户当前系统的一个综合排名，比如活跃度、贡献度等。

#### 违背原则方案

- 定义抽奖用户

```java
public class BetUser {

    private String userName;  // 用户姓名
    private int userWeight;   // 用户权重

    public BetUser() {
    }

    public BetUser(String userName, int userWeight) {
        this.userName = userName;
        this.userWeight = userWeight;
    }

    public String getUserName() {
        return userName;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }

    public int getUserWeight() {
        return userWeight;
    }

    public void setUserWeight(int userWeight) {
        this.userWeight = userWeight;
    }
}
```

- 定义实现两种不同抽奖逻辑

```java
public class DrawControl {

    // 随机抽取指定数量的用户，作为中奖用户
    public List<BetUser> doDrawRandom(List<BetUser> list, int count) {
        // 集合数量很小直接返回
        if (list.size() <= count) return list;
        // 乱序集合
        Collections.shuffle(list);
        // 取出指定数量的中奖用户
        List<BetUser> prizeList = new ArrayList<>(count);
        for (int i = 0; i < count; i++) {
            prizeList.add(list.get(i));
        }
        return prizeList;
    }

    // 权重排名获取指定数量的用户，作为中奖用户
    public List<BetUser> doDrawWeight(List<BetUser> list, int count) {
        // 按照权重排序
        list.sort((o1, o2) -> {
            int e = o2.getUserWeight() - o1.getUserWeight();
            if (0 == e) return 0;
            return e > 0 ? 1 : -1;
        });
        // 取出指定数量的中奖用户
        List<BetUser> prizeList = new ArrayList<>(count);
        for (int i = 0; i < count; i++) {
            prizeList.add(list.get(i));
        }
        return prizeList;
    }

}
```

​		在这个抽奖逻辑类中包含了两个方法，一个随机抽奖，另外一个按照权重排序。

> 如果程序是一次性的，几乎不变的，那么可以考虑很多的扩展和可能性因素；但是如果这些程序具有不确定性，或者当业务发展需要不断的调整和新增，那么这样的实现方式就很不友好了。

#### 依赖倒置原则改善代码

​		既然上述方式不具备好的扩展性，那么用于依赖倒置、面向抽象编程的方式实现。

​		首先定义抽奖的功能的接口，任何一个实现方都可以实现自己的抽奖逻辑。

- 抽奖接口

```java
public interface IDraw {

    // 获取中奖用户接口
    List<BetUser> prize(List<BetUser> list, int count);

}
```

- 随机抽奖事项

```java
public class DrawRandom implements IDraw {

    @Override
    public List<BetUser> prize(List<BetUser> list, int count) {
        // 集合数量很小直接返回
        if (list.size() <= count) return list;
        // 乱序集合
        Collections.shuffle(list);
        // 取出指定数量的中奖用户
        List<BetUser> prizeList = new ArrayList<>(count);
        for (int i = 0; i < count; i++) {
            prizeList.add(list.get(i));
        }
        return prizeList;
    }

}
```

- 权重实现

```java
public class DrawWeightRank implements IDraw {

    @Override
    public List<BetUser> prize(List<BetUser> list, int count) {
        // 按照权重排序
        list.sort((o1, o2) -> {
            int e = o2.getUserWeight() - o1.getUserWeight();
            if (0 == e) return 0;
            return e > 0 ? 1 : -1;
        });
        // 取出指定数量的中奖用户
        List<BetUser> prizeList = new ArrayList<>(count);
        for (int i = 0; i < count; i++) {
            prizeList.add(list.get(i));
        }
        return prizeList;
    }

}
```

- 创建抽奖服务

```java
public class DrawControl {

    //private IDraw draw;

    public List<BetUser> doDraw(IDraw draw, List<BetUser> betUserList, int count) {
        return draw.prize(betUserList, count);
    }

}
```

​		在这个类中体现了依赖倒置的重要性，可以把任何一种抽奖逻辑传递给这个类。这样实现的好处是可以不断的扩展，但是不需要在外部新增调用的接口，降低一套代码的维护成本，并提高可扩展及可维护性。

​		另外，这里的重点是把实现逻辑的接口作为参数传递，在一些框架源码中经常会这样的做法。
