# 一对多

- 计划书视频-异步任务

# 多对多

![image-20220513230032723](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202205132300783.png)

我们在一个长连接服务器中使用了这种模式，生产者1负责将所有客户端发送的消息存放 在阻塞队列1里，消费者1从队列里读消息，然后通过消息ID进行散列得到N个队列中的一个， 然后根据编号将消息存放在到不同的队列里，每个阻塞队列会分配一个线程来消费阻塞队列里的数据。如果消费者2无法消费消息，就将消息再抛回到阻塞队列1中，交给其他消费者处 理。

# 线程池与生产消费者模式

​		Java中的线程池类其实就是一种生产者和消费者模式的实现方式，但是我觉得其实现方 式更加高明。生产者把任务丢给线程池，线程池创建线程并处理任务，如果将要运行的任务数 大于线程池的基本线程数就把任务扔到阻塞队列里，这种做法比只使用一个阻塞队列来实现 生产者和消费者模式显然要高明很多，因为消费者能够处理直接就处理掉了，这样速度更快， 而生产者先存，消费者再取这种方式显然慢一些。

# 使用多个线程池

​		我们的系统也可以使用线程池来实现多生产者和消费者模式。例如，创建N个不同规模的 Java线程池来处理不同性质的任务，比如线程池1将数据读到内存之后，交给线程池2里的线程 继续处理压缩数据。线程池1主要处理IO密集型任务，线程池2主要处理CPU密集型任务。