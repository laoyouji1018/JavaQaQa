# 设计模式之单例模式

## 定义

> 在当前进程中，通过单例模式创建的类有且只有一个实例。

## 单例模式的特点

- 在Java应用中，单例模式能保证在一个JVM中，该对象只有一个实例存在
- 构造器必须是私有的，外部类无法通过调用构造器方法创建该实例
- 没有公开的set方法，外部类无法调用set方法创建该实例
- 提供一个公开的get方法获取唯一的这个实例

## 单例模式的优点

- 某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销
- 省去了new操作符，降低了系统内存的使用频率，减轻GC压力
- 系统中某些类，如spring里的controller，控制着处理流程，如果该类可以创建多个的话，系统完全乱了
- 避免了对资源的重复占用

## 7种写法

1.懒汉模式，单例实例在第一次使用时进行创建，非线程安全

```java
public class SingletonDemo1 {
    //私有构造方法
    private SingletonDemo1() {//1
    }
    //单例对象
    private static SingletonDemo1 instance = null;//2
    //静态工厂方法
    public static SingletonDemo1 getInstance() {//3
        if (instance == null) {//多线程的情况下，在此处会导致线程安全的问题//4
            instance = new SingletonDemo1();//5
        }
        return instance;//6
    }
}
```

**解释说明**

> 假如当线程A先去执行，执行到第4句话的时候（第六句话执行完了），恰好停止了，这时候线程B就开始执行，线程B执行完第7句话才停止，释放资源让线程A去执行，但是A已经判断过了啊，已经执行完第六句话了啊，于是A继续执行第5句话，于是再次new了一个Singleton对象，因此，虽然已经判断了但是还是造了两个对象出来，到此分析完毕！

2.饿汉模式，单例实例在类装载时进行创建，线程安全

```java
/**
 * @program: Singleton
 * @description: 饿汉模式，单例实例在类装载时进行创建，<b>线程安全</b>
 * @author: Mr.superbeyone
 * @create: 2018-09-30 09:21
 **/
public class SingletonDemo2 {
    //私有构造方法
    private SingletonDemo2() {
    }
    //单例对象  //1
    private static SingletonDemo2 instance = new SingletonDemo2();
    //静态的工厂方法
    public static SingletonDemo2 getInstance() {
        return instance;
    }
}
```

> 代码1处的解释：jvm在加载该SingletonDemo2类时，会进过`装载，链接，初始化`阶段，在链接阶段会给予静态变量默认值（默认值如下表格），而在初始化阶段会修改为真正的值

| 数据类型 | 默认值 |
| -------- | ------ |
| byte     | 0      |
| short    | 0      |
| int      | 0      |
| long     | 0      |
| float    | 0.0    |
| double   | 0.0    |
| char     | （空） |
| boolean  | false  |
| 引用类型 | null   |

3.懒汉模式，单例实例在第一次使用时进行创建，线程安全，不推荐使用

```java
/**
 * @program: Singleton
 * @description: 懒汉模式，单例实例在第一次使用时进行创建，<b>线程安全，不推荐使用</b>
 * @author: Mr.superbeyone
 * @create: 2018-09-30 09:29
 **/
public class SingletonDemo3 {
    //私有构造方法
    private SingletonDemo3() {
    }
    //单例对象
    private static SingletonDemo3 instance = null;
    //静态工厂方法
    public static synchronized SingletonDemo3 getInstance() {//1
        if (instance == null) {
            instance = new SingletonDemo3();
        }
        return instance;
    }
}
```

解释说明

> 线程安全的原因：代码1处，`synchronized`关键字保证了方法再多线程的情况下是安全的

4.懒汉模式，双重同步锁单例模式，单例实例在第一次使用时创建，非线程安全

```java
/**
 * @program: Singleton
 * @description: 懒汉模式，双重同步锁单例模式，单例实例在第一次使用时创建，<b>非线程安全</b>
 * @author: Mr.superbeyone
 * @create: 2018-09-30 09:38
 **/
public class SingletonDemo4 {
    //私有构造方法
    private SingletonDemo4() {
    }
    //单例对象
    private static SingletonDemo4 instance = null;
    //静态工厂方法
    public static SingletonDemo4 getInstance() {
        //双重检测机制
        if (instance == null) {//1
            //同步锁
            synchronized (SingletonDemo4.class) {//2
                if (instance == null) {//3
                    instance = new SingletonDemo4();
                }
            }
        }
        return instance;
    }
}
```

解释说明

> 双重同步锁可拆分为`双重``同步`锁两块
>
> 双重：代码1和代码3做了两次判空
>
> 同步锁：synchronized修饰代码块，对象锁为`SingletonDemo4`类对象，所以只能有一个线程能访问代码块里面的内容，保证创建同时只会有一个线程执行

1. 懒汉模式，双重同步锁单例模式，单例实例在第一次使用时创建，非线程安全

   ```java
   /**
    * @program: Singleton
    * @description: 懒汉模式，双重同步锁单例模式，单例实例在第一次使用时创建，<b>线程安全</b>
    * @author: Mr.superbeyone
    * @create: 2018-09-30 09:45
    **/
   public class SingletonDemo5 {
       //私有构造方法
       private SingletonDemo5() {
       }
       //单例对象 volatile + 双重检测机制 -> 禁止指令重排（看下面的图片）
       private volatile static SingletonDemo5 instance = null;
       //静态工厂方法
       public static SingletonDemo5 getInstance() {
           //双重检测机制
           if (instance == null) {
               //同步锁
               synchronized (SingletonDemo5.class) {
                   if (instance == null) {
                       instance = new SingletonDemo5();
                   }
               }
           }
           return instance;
       }
   }
   ```

   ![clipboard](https://cdn.jsdelivr.net/zjmJavaByte/images/images@master/images/clipboard.png)

2. 饿汉模式，单例实例在类装载时进行创建，线程安全

   ```java
   /**
    * @program: my-blog
    * @description: 饿汉模式，单例实例在类装载时进行创建，<b>线程安全</b>
    * @author: Mr.superbeyone
    * @create: 2018-09-30 09:56
    **/
   public class SingletonDemo6 {
       //私有构造方法
       private SingletonDemo6() {
       }
       //单例对象
       private static SingletonDemo6 instance = null;
       static {
           instance = new SingletonDemo6();
       }
       //静态工厂方法
       public static SingletonDemo6 getInstance() {
           return instance;
       }
   }
   ```

   解释说明

   > 类装载的时候，static静态代码块，保证只会被执行一次

3. 枚举模式，线程安全，推荐使用

   ```java
   /**
    * @program: Singleton
    * @description: 枚举模式，<b>线程安全，推荐使用</b>
    * @author: Mr.superbeyone
    * @create: 2018-09-30 09:59
    **/
   public class SingletonDemo7 {
       //私有构造方法
       private SingletonDemo7() {
       }
       public static SingletonDemo7 getInstance() {
           return Singleton.INSTANCE.getInstance();
       }
       private enum Singleton {
           INSTANCE;
           private SingletonDemo7 singleton;
           //JVM保证这个方法绝对只调用一次
           Singleton() {
               singleton = new SingletonDemo7();
           }
           private SingletonDemo7 getInstance() {
               return singleton;
           }
       }
   }
   ```

   