# 设计模式之单例模式

## 定义

> 在当前进程中，通过单例模式创建的类有且只有一个实例。

## 单例模式的特点

- 在Java应用中，单例模式能保证在一个JVM中，该对象只有一个实例存在
- 构造器必须是私有的，外部类无法通过调用构造器方法创建该实例
- 没有公开的set方法，外部类无法调用set方法创建该实例
- 提供一个公开的get方法获取唯一的这个实例

## 单例模式的优点

- 某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销
- 省去了new操作符，降低了系统内存的使用频率，减轻GC压力
- 系统中某些类，如spring里的controller，控制着处理流程，如果该类可以创建多个的话，系统完全乱了
- 避免了对资源的重复占用

## 7种写法

1.懒汉模式，单例实例在第一次使用时进行创建，非线程安全

```java
public class SingletonDemo1 {
    //私有构造方法
    private SingletonDemo1() {//1
    }
    //单例对象
    private static SingletonDemo1 instance = null;//2
    //静态工厂方法
    public static SingletonDemo1 getInstance() {//3
        if (instance == null) {//多线程的情况下，在此处会导致线程安全的问题//4
            instance = new SingletonDemo1();//5
        }
        return instance;//6
    }
}
```

**解释说明**

> 假如当线程A先去执行，执行到第4句话的时候（第六句话执行完了），恰好停止了，这时候线程B就开始执行，线程B执行完第7句话才停止，释放资源让线程A去执行，但是A已经判断过了啊，已经执行完第六句话了啊，于是A继续执行第5句话，于是再次new了一个Singleton对象，因此，虽然已经判断了但是还是造了两个对象出来，到此分析完毕！

2.饿汉模式，单例实例在类装载时进行创建，线程安全

```java
/**
 * @program: Singleton
 * @description: 饿汉模式，单例实例在类装载时进行创建，<b>线程安全</b>
 * @author: Mr.superbeyone
 * @create: 2018-09-30 09:21
 **/
public class SingletonDemo2 {
    //私有构造方法
    private SingletonDemo2() {
    }
    //单例对象  //1
    private static SingletonDemo2 instance = new SingletonDemo2();
    //静态的工厂方法
    public static SingletonDemo2 getInstance() {
        return instance;
    }
}
```

> 代码1处的解释：jvm在加载该SingletonDemo2类时，会进过装载，链接，初始化阶段，在链接阶段会给予静态变量默认值（默认值如下表格），而在初始化阶段会修改为真正的值

| 数据类型 | 默认值 |
| -------- | ------ |
| byte     | 0      |
| short    | 0      |
| int      | 0      |
| long     | 0      |
| float    | 0.0    |
| double   | 0.0    |
| char     | （空） |
| boolean  | false  |
| 引用类型 | null   |

1. 懒汉模式，单例实例在第一次使用时进行创建，线程安全，不推荐使用
2. 懒汉模式，双重同步锁单例模式，单例实例在第一次使用时创建，非线程安全
3. 懒汉模式，双重同步锁单例模式，单例实例在第一次使用时创建，非线程安全
4. 饿汉模式，单例实例在类装载时进行创建，线程安全
5. 枚举模式，线程安全，推荐使用