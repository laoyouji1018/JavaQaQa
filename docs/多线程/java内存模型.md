# java内存模型

## 主内存与工作内存

​		**Java内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到 内存和从内存中取出变量值这样的底层细节。**此处的变量(`Variables`)与Java编程中所说的变量有所区 别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，因为后者是线程私有的[1]，不会被共享，自然就不会存在竞争问题。

​		Java内存模型规定了所有的变量都存储在主内存(`Main Memory`)中。每条线程 还有自己的工作内存(`Working Memory` )，线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作(读取、赋值等)都必须在工作内存中进行，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变 量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如图所示：

![image-20220505144127792](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202205051441818.png)

## 内存间的交互

​		关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从 工作内存同步回主内存这一类的实现细节，Java内存模型中定义了以下8种操作来完成。Java虚拟机实 现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于`double和long`类型的变量来说，`load、store、read和write`操作在某些平台上允许有例外）:

- lock(锁定):作用于主内存的变量，它把一个变量标识为一条线程独占的状态。

- unlock(解锁):作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量 才可以被其他线程锁定。

- read(读取):作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以 便随后的`load`动作使用。

- load(载入):作用于工作内存的变量，它把`read`操作从主内存中得到的变量值放入工作内存的 变量副本中。

- use(使用):作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚 拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。

- assign(赋值):作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量， 每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。

- store(存储):作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随 后的`write`操作使用。

- write(写入):作用于主内存的变量，它把`store`操作从工作内存中得到的变量的值放入主内存的 变量中。

Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则:

- 不允许`read和load、store和write`操作之一单独出现，即不允许一个变量从主内存读取了但工作内 存不接受，或者工作内存发起回写了但主内存不接受的情况出现。

- 不允许一个线程丢弃它最近的`assign`操作，即变量在工作内存中改变了之后必须把该变化同步回 主内存。

- 不允许一个线程无原因地(没有发生过任何`assign`操作)把数据从线程的工作内存同步回主内存 中。·一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化(`load或 assign`)的变量，换句话说就是对一个变量实施`use、store`操作之前，必须先执行`assign和load`操作。

- 一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执 行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。

- 如果对一个变量执行`lock`操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量 前，需要重新执行`load或assign`操作以初始化变量的值。

- 如果一个变量事先没有被`lock`操作锁定，那就不允许对它执行`unlock`操作，也不允许去`unlock`一个 被其他线程锁定的变量。

- 对一个变量执行`unlock`操作之前，必须先把此变量同步回主内存中(执行`store、write`操作)。

## 内存模型特征

### 原子性

​		由Java内存模型来直接保证的原子性变量操作包括`read、load、assign、us e、store和write`这六个， 我们大致可以认为，基本数据类型的访问、读写都是具备原子性的(例外就是`long和double`的非原子性协定，读者只要知道这件事情就可以了，无须太过在意这些几乎不会发生的例外情况)。

​		如果应用场景需要一个更大范围的原子性保证(经常会遇到)，Java内存模型还提供了`lock和 unlock`操作来满足这种需求，尽管虚拟机未把`lock和unlock`操作直接开放给用户使用，但是却提供了更 高层次的字节码指令`monitorenter和monitorexit` 来隐式地使用这两个操作。这两个字节码指令反映到Java 代码中就是同步块——`synchronized`关键字，因此在`synchronized`块之间的操作也具备原子性。

### 可见性

​		**可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。**Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是 普通变量还是`volatile`变量都是如此。普通变量与`volatile`变量的区别是，`volatile`的特殊规则保证了新值 能立即同步到主内存，以及每次使用前立即从主内存刷新。因此我们可以说`volatile`保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。

​		除了`volatile`之外，Java还有两个关键字能实现可见性，它们是`sy nchronized和final`。同步块的可见 性是由“对一个变量执行`unlock`操作之前，必须先把此变量同步回主内存中(执行`store、write`操 作)”这条规则获得的。而`final`关键字的可见性是指：被final修饰的字段在构造器中一旦被初始化完 成，并且构造器没有把`this`的引用传递出去(`this`引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象)

`this`的引用传递出去案列

```java
public class FinalTest {
    final int i;

    static FinalTest obj;

    public FinalTest() {
        i = 1;
/**
 *这里会使正在被构造的对象逸出，如果和上一句做了重排序，那么其他线程就可以通过obj访问到还为被初始化的final域。
 **/
        obj = this;
    }
}
```

`this`的引用未传递出去案列

```java
public static final int i;
public final int j;
static {
	i = 0;
	// 省略后续动作 
}
{
	// 也可以选择在构造函数中初始化 
  j = 0;
	// 省略后续动作
}
```

那么在其他线程中就能看见`final`字段的值。如代码清单所示，变量`i与j`都具备可见性，它们无须同步就能被其他线程正确访问。

### 有序性