#### 题目

> 给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。
>
> 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
>
> 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

#### 示例 1:

> 输入: prices = [7,1,5,3,6,4]
> 输出: 7
> 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
>      随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。

#### 示例 2:

> 输入: prices = [1,2,3,4,5]
> 输出: 4
> 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
>      注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

#### 示例 3:

> 输入: prices = [7,6,4,3,1]
> 输出: 0
> 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

#### 答案

- 动态规划解决

`定义dp[i][0]表示第i+1天交易完之后手里没有股票的最大利润，dp[i][1]表示第i+1天交易完之后手里持有股票的最大利润。`

当天交易完之后手里**没有股票**可能有两种情况，**一种是当天没有进行任何交易**，又因为当天手里没有股票，所以当天没有股票的利润只能取前一天手里没有股票的利润。**一种是把当天手里的股票给卖了**，既然能卖，说明手里是有股票的，所以这个时候当天没有股票的利润要取前一天手里有股票的利润加上当天股票能卖的价格。这两种情况我们取利润最大的即可，所以可以得到

`dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i]);`

当天交易完之后手里**持有股票**也有两种情况，**一种是当天没有任何交易**，又因为当天手里持有股票，所以当天手里持有的股票其实前一天就已经持有了。**还一种是当天买入了股票**，当天能买股票，说明前一天手里肯定是没有股票的，我们取这两者的最大值，所以可以得到

`dp[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i]);`

动态规划的递推公式有了，那么边界条件是什么，就是第一天

如果买入：`dp[0][1]=-prices[0];`

如果没买：`dp[0][0]=0;`

有了递推公式和边界条件，代码很容易就写出来了。

```java
public int maxProfit(int[] prices) {
    if (prices == null || prices.length < 2)
        return 0;
    int length = prices.length;
    int[][] dp = new int[length][2];
    //初始条件
    dp[0][1] = -prices[0];
    dp[0][0] = 0;
    for (int i = 1; i < length; i++) {
        //递推公式
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
    }
    //最后一天肯定是手里没有股票的时候，利润才会最大，
    //只需要返回dp[length - 1][0]即可
    return dp[length - 1][0];
}
```

- 代码优化
	上面计算的时候我们看到当天的利润只和前一天有关，没必要使用一个二维数组，只需要使用两个变量，一个记录当天交易完之后手里持有股票的最大利润，一个记录当天交易完之后手里没有股票的最大利润，来看下代码

```java
public int maxProfit(int[] prices) {
    if (prices == null || prices.length < 2)
        return 0;
    int length = prices.length;
    //初始条件
    int hold = -prices[0];//持有股票
    int noHold = 0;//没持有股票
    for (int i = 1; i < length; i++) {
        //递推公式转化的
        noHold = Math.max(noHold, hold + prices[i]);
        hold = Math.max(hold, noHold - prices[i]);
    }
    //最后一天肯定是手里没有股票的时候利润才会最大，
    //所以这里返回的是noHold
    return noHold;
}
```

- 贪心算法解决

下面我随便画了一个股票的曲线图，可以看到如果股票一直上涨，只需要找到**股票上涨的最大值**和股票**开始上涨的最小值**，计算他们的差就是这段时间内股票的最大利润。如果股票下跌就不用计算，最终只需要把所有股票上涨的时间段内的利润累加就是我们所要求的结果

![](https://gitee.com/laoyouji1018/images/raw/master/img/20210725001643.png)

来看下代码

```java
public int maxProfit(int[] prices) {
    if (prices == null || prices.length < 2)
        return 0;
    int total = 0, index = 0, length = prices.length;
    while (index < length) {
        //如果股票下跌就一直找，直到找到股票开始上涨为止
        while (index < length - 1 && prices[index] >= prices[index + 1])
            index++;
        //股票上涨开始的值，也就是这段时间上涨的最小值
        int min = prices[index];
        //一直找到股票上涨的最大值为止
        while (index < length - 1 && prices[index] <= prices[index + 1])
            index++;
        //计算这段上涨时间的差值，然后累加
        total += prices[index++] - min;
    }
    return total;
}
```

贪心算法是指，在对问题求解时，**总是做出在当前看来是最好的选择**。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解。

那么这道题使用贪心算法也是最容易解决的，只要是上涨的我们就要计算他们的差值进行累加，不需要再找开始上涨的最小值和最大值。为什么能这样计算，我举个例子。

比如a<b<c<d，因为从**a到d一直是上涨的**，那么最大值和最小值的差值就是d-a，也可以写成(b-a)+(c-b)+(d-c)，搞懂了这个公式所有的一切都明白了。如果还不明白，可以想象成数组中前一个值减去后一个值，构成一个新的数组，**我们只需要计算这个新数组中正数的和即可**，这里以示例1为例画个图看下

我们只需要计算这个新数组中正数的和即可，这里以示例1为例画个图看下

![](https://gitee.com/laoyouji1018/images/raw/master/img/20210725001821.png)

这里只需要计算新数组中正数的和，也就是4+3=7。这个时候代码就已经非常简化了，我们来看下

```java
public int maxProfit(int[] prices) {
    int total = 0;
    for (int i = 0; i < prices.length - 1; i++) {
        //原数组中如果后一个减去前一个是正数，说明是上涨的，
        //我们就要累加，否则就不累加
        total += Math.max(prices[i + 1] - prices[i], 0);
    }
    return total;
}
```

