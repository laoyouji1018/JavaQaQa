- 每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出的操作数栈

- 操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈或出栈某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈，使用他们后再把结果压入栈(如字节码指令bipush操作)

比如：执行复制、交换、求和等操作


### 操作数栈的特点

- 操作数栈，`主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间` 

- 操作数栈就是JVM执行引擎的一个工作区，当一个方法开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的

- 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，`其所需的最大深度在编译器就定义好了，保存在方法的code属性中，为max_stack的值`。

- 栈中的任何一个元素都是可以任意的Java数据类型

  - 32bit的类型占用一个栈单位深度

  - 64bit的类型占用两个栈深度单位

- `操作数栈并非采用访问索引的方式来进行数据访问的`，而是只能通过标准的入栈push和出栈pop操作来完成一次数据访问

- **如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，**并更新PC寄存器中下一条需要执行的字节码指令
- 操作数栈中的元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类验证阶段的数据流分析阶段要再次验证
- 另外，我们说Java虚拟机的**解释引擎**是基于栈的执行引擎，其中的栈指的就是操作数栈

### 操作数栈具体演示

下面我们以此代码进行演示

![](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204111706485.png)

①15入栈、②存储15，15进入局部变量表

![](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204111707153.png)

③压入8、④8出栈，存储8进入局部变量表

![](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204111707504.png)

⑤从局部变量表中把索引为1和2的是数据取出来，放到操作数栈、⑥iadd相加操作

![](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204111707055.png)

⑦iadd操作结果23出栈并且操作数栈清空、⑧将23存储在局部变量表索引为3的位置上istore_3


[参考文章](https://blog.csdn.net/qq_42868566/article/details/114732340)