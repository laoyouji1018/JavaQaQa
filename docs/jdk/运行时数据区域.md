[TOC]

## 运行时数据区域

Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着`虚拟机进程`的启动而一直存在，有些区域则是依赖`用户线程`的启动和结束而建立和销毁。

![image-20220411135554948](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204111355026.png)

### 程序计数器

程序计数器(Program Counter Register)是一块`较小的内存空间`，它可以看作是当前线程所执行的字节码的`行号指示器`：

- Java方法：计数器记录的是正在执行的虚拟机字节码指令的地 址

- 本地方法：计数器值则应为空(Undefined)

由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称`这类内存区域为线程私有的内存`。

此内存区域是唯 一一个在《Java虚拟机规范》中没有规定任何`OutOfMemoryError`情况的区域。

### Java虚拟机栈

虚拟机栈描述的是Java方法执行的线程`内存模型`:每个方法被执行的时候，Java虚拟机都会同步创建一个`栈帧`用于存储[局部变量表](https://github.com/zjmJavaByte/JavaQaaQ/blob/master/docs/jdk/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8.md)、[操作数栈](https://github.com/zjmJavaByte/JavaQaaQ/blob/master/docs/jdk/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88.md)、[动态连接](https://github.com/zjmJavaByte/JavaQaaQ/blob/master/docs/jdk/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5.m)、[方法出口](https://github.com/zjmJavaByte/JavaQaaQ/blob/master/docs/jdk/%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80.md)等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

![image-20220411143532679](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204111435712.png)

- 栈帧存在于虚拟机栈中，并且是虚拟机栈中的单位元素
- **每个线程中的不同栈帧对应这个线程调用的不同方法**，可以看到栈帧很多，调用的方法链也会很多
- 在活动线程中，只有当前栈帧有效，与之对应的也就是当前正在执行的方法，此方法被成为当前方法
- 每调用一个新的方法，此方法对应的栈帧就会被放到栈顶（入栈），也就是成为新的当前栈帧；当一个方法退出的时候，此方法对应的栈帧也相应销毁（出栈）【递归的原理】

栈帧中需要多大的局部变量表，多深的操作数栈在编译成 .class 文件的时候都是已经确定好的，这些信息都存储在方法表中的 code 属性中，因此每个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响。

回顾一下方法表及 code 属性的定义。

- **方法表**：.class 文件中的方法表包含了此方法的一些信息：访问标志（public、private 等）、名称索引（指向常量池）、描述符索引（指向常量池，描述符用来描述方法的参数列表以及返回值）、属性表集合。
- **code 属性的定义**：code 属性存储在属性表中，而属性表是多种属性的集合。code 属性存放的就是经过编译器编译成字节码指令的 Java 方法里面的代码（里面记录了局部变量表的大小与操作数栈的深度）。

方法表中不一定需要属性表，因为如果这是一个抽象方法，那么这个方法生成的方法表中就不需要存在属性表（这个 Java 方法没有被定义，属性表中的其他属性也无法被生成）

#### Java 虚拟机栈会出现的异常

**在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况:**如果线程请求的栈深度大于虚拟机所允许的深度，将抛出`StackOverflowError`异常;如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出`OutOfMemoryError`异常

- `如果线程请求的栈深度大于虚拟机所允许的最大深度`，将抛出StackOverflowError异常。 

```java
package org.fenixsoft.jvm.chapter2;

/**
 * VM Args：-Xss128k
 *
 * @author zzm
 */
public class JavaVMStackSOF_1 {

    private int stackLength = 1;

    public void stackLeak() {
        stackLength++;
        stackLeak();
    }

    public static void main(String[] args) {
        JavaVMStackSOF_1 oom = new JavaVMStackSOF_1();
        try {
            oom.stackLeak();
        } catch (Throwable e) {
            System.out.println("stack length:" + oom.stackLength);
            throw e;
        }
    }
}

```

- 如果虚拟机的栈内存允许动态扩展，`当扩展栈容量无法申请到足够的内存`时，将抛出OutOfMemoryError异常。

### 本地方法栈

​		本地方法栈(Native M ethod Stacks)与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则是为虚拟机使用到的本地(Native) 方法服务。

**Hot-Spot虚拟机直接 就把本地方法栈和虚拟机栈合二为一**

### Java堆

#### 特点

- **Java 堆（Java Heap）是 Java 虚拟机所管理的内存中最大的一块**，也被称为 “GC堆”，是被所有**线程共享**的一块内存区域，**在虚拟机启动时被创建**。

- 唯一目的就是**储存对象实例和数组**（JDK7 已把**字符串常量池和类静态变量**移动到 Java 堆），几乎所有的对象实例都会存储在堆中分配。随着 **JIT 编译器**发展，**逃逸分析、栈上分配、标量替换**等优化技术导致并不是所有对象都会在堆上分配。

- **Java 堆是垃圾收集器管理的主要区域**。堆内存分为新生代 (Young) 和老年代 (Old) ，新生代 (Young) 又被划分为三个区域：Eden、From Survivor、To Survivor。

- ![img](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204121203747.png)

  堆默认内存划分

- 从内存分配的角度看，线程共享的 Java 堆中可能划分出多个线程私有的**线程本地分配缓存区（Thread Local Allocation Buffer，TLAB）**。

- 根据 Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过 `-Xmx` 和 `-Xms` 控制）。

#### Java 堆会出现的异常

- 如果 Java 堆可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，那 Java 虚拟机将抛出一个 **OutOfMemoryError** 异常。





### 方法区

### 运行时常亮池

### 直接内存