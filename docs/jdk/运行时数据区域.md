[TOC]

## 运行时数据区域

Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着`虚拟机进程`的启动而一直存在，有些区域则是依赖`用户线程`的启动和结束而建立和销毁。

![image-20220411135554948](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204111355026.png)

### 栈、堆、方法区 的相关关系

从线程共享角度来看

![](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204121734551.png)

交互关系

![](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204121735069.png)

> 上图：Person.class 对象是存储在方法区中，person局部变量是在Java栈中，new 的 Person 对象是存储在 Java 堆中。

### 程序计数器

程序计数器(Program Counter Register)是一块`较小的内存空间`，它可以看作是当前线程所执行的字节码的`行号指示器`：

- Java方法：计数器记录的是正在执行的虚拟机字节码指令的地 址

- 本地方法：计数器值则应为空(Undefined)

由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称`这类内存区域为线程私有的内存`。

此内存区域是唯 一一个在《Java虚拟机规范》中没有规定任何`OutOfMemoryError`情况的区域。

### Java虚拟机栈

虚拟机栈描述的是Java方法执行的线程`内存模型`:每个方法被执行的时候，Java虚拟机都会同步创建一个`栈帧`用于存储[局部变量表](https://github.com/zjmJavaByte/JavaQaaQ/blob/master/docs/jdk/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8.md)、[操作数栈](https://github.com/zjmJavaByte/JavaQaaQ/blob/master/docs/jdk/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88.md)、[动态连接](https://github.com/zjmJavaByte/JavaQaaQ/blob/master/docs/jdk/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5.m)、[方法出口](https://github.com/zjmJavaByte/JavaQaaQ/blob/master/docs/jdk/%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80.md)等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

![image-20220411143532679](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204111435712.png)

- 栈帧存在于虚拟机栈中，并且是虚拟机栈中的单位元素
- **每个线程中的不同栈帧对应这个线程调用的不同方法**，可以看到栈帧很多，调用的方法链也会很多
- 在活动线程中，只有当前栈帧有效，与之对应的也就是当前正在执行的方法，此方法被成为当前方法
- 每调用一个新的方法，此方法对应的栈帧就会被放到栈顶（入栈），也就是成为新的当前栈帧；当一个方法退出的时候，此方法对应的栈帧也相应销毁（出栈）【递归的原理】

栈帧中需要多大的局部变量表，多深的操作数栈在编译成 .class 文件的时候都是已经确定好的，这些信息都存储在方法表中的 code 属性中，因此每个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响。

回顾一下方法表及 code 属性的定义。

- **方法表**：.class 文件中的方法表包含了此方法的一些信息：访问标志（public、private 等）、名称索引（指向常量池）、描述符索引（指向常量池，描述符用来描述方法的参数列表以及返回值）、属性表集合。
- **code 属性的定义**：code 属性存储在属性表中，而属性表是多种属性的集合。code 属性存放的就是经过编译器编译成字节码指令的 Java 方法里面的代码（里面记录了局部变量表的大小与操作数栈的深度）。

方法表中不一定需要属性表，因为如果这是一个抽象方法，那么这个方法生成的方法表中就不需要存在属性表（这个 Java 方法没有被定义，属性表中的其他属性也无法被生成）

#### Java 虚拟机栈会出现的异常

**在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况:**如果线程请求的栈深度大于虚拟机所允许的深度，将抛出`StackOverflowError`异常;如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出`OutOfMemoryError`异常

- `如果线程请求的栈深度大于虚拟机所允许的最大深度`，将抛出StackOverflowError异常。 

```java
package org.fenixsoft.jvm.chapter2;

/**
 * VM Args：-Xss128k
 *
 * @author zzm
 */
public class JavaVMStackSOF_1 {

    private int stackLength = 1;

    public void stackLeak() {
        stackLength++;
        stackLeak();
    }

    public static void main(String[] args) {
        JavaVMStackSOF_1 oom = new JavaVMStackSOF_1();
        try {
            oom.stackLeak();
        } catch (Throwable e) {
            System.out.println("stack length:" + oom.stackLength);
            throw e;
        }
    }
}

```

- 如果虚拟机的栈内存允许动态扩展，`当扩展栈容量无法申请到足够的内存`时，将抛出OutOfMemoryError异常。

### 本地方法栈

​		本地方法栈(Native M ethod Stacks)与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则是为虚拟机使用到的本地(Native) 方法服务。

**Hot-Spot虚拟机直接 就把本地方法栈和虚拟机栈合二为一**

### Java堆

#### 特点

- **Java 堆（Java Heap）是 Java 虚拟机所管理的内存中最大的一块**，也被称为 “GC堆”，是被所有**线程共享**的一块内存区域，**在虚拟机启动时被创建**。

- 唯一目的就是**储存对象实例和数组**（JDK7 已把**字符串常量池和类静态变量**移动到 Java 堆），几乎所有的对象实例都会存储在堆中分配。随着 **JIT 编译器**发展，**[逃逸分析、栈上分配、标量替换](https://github.com/zjmJavaByte/JavaQaaQ/blob/master/docs/jdk/JIT%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8.md)**等优化技术导致并不是所有对象都会在堆上分配。

- **Java 堆是垃圾收集器管理的主要区域**。堆内存分为新生代 (Young) 和老年代 (Old) ，新生代 (Young) 又被划分为三个区域：Eden、From Survivor、To Survivor。

- ![img](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204121203747.png)

  堆默认内存划分

- 从内存分配的角度看，线程共享的 Java 堆中可能划分出多个线程私有的**线程本地分配缓存区（Thread Local Allocation Buffer，TLAB）**。

  - TLAB 的全称是 Thread Local Allocation Buffer，即线程本地分配缓存区。这是线程私有的，在新生代 Eden 区分配内存区域，默认是开启的，也可以通过 `-XX:+UseTLAB` 开启。TLAB 的内存非常小，默认设定为占用新生代的1%，可以通过 `-XX:TLABWasteTargetPercent` 设置 TLAB 占用 Eden Space 空间大小。
  - 由于对象一般会分配在堆上，而堆是全局共享的。同一时间，可能会有多个线程在堆上申请空间。因此，每次对象分配都必须要进行同步，而在竞争激烈的场合内存分配的效率又会进一步下降。JVM 使用 TLAB 来避免多线程冲突，每个线程使用自己的 TLAB，这样就保证了不使用同步，提高了对象分配的效率。
  - 由于 TLAB 空间一般不会很大，因此大对象无法在 TLAB 上进行分配，总是会直接分配在堆上。TLAB 空间由于比较小，因此很容易装满。比如，一个100K的空间，已经使用了80KB，当需要再分配一个30KB的对象时，肯定就无能为力了。这时虚拟机会有两种选择，第一，废弃当前 TLAB，这样就会浪费20KB空间；第二，将这30KB的对象直接分配在堆上，保留当前的 TLAB，这样可以希望将来有小于20KB的对象分配请求可以直接使用这块空间。实际上虚拟机内部会维护一个叫作 refill_waste 的值，当请求对象大于 refill_waste 时，会选择在堆中分配，若小于该值，则会废弃当前 TLAB，新建 TLAB 来分配对象。这个阈值可以使用 `-XX:TLABRefillWasteFraction` 来调整，它表示 TLAB 中允许产生这种浪费的比例。默认值为64，即表示使用约为1/64的 TLAB 空间作为 refill_waste。默认情况下，TLAB 和 refill_waste 都会在运行时不断调整的，使系统的运行状态达到最优。如果想要禁用自动调整 TLAB 的大小，可以使用 `-XX:-ResizeTLAB` 禁用，并使用 `-XX:TLABSize` 手工指定一个 TLAB 的大小。`-XX:+PrintTLAB` 可以跟踪TLAB的使用情况。一般不建议手工修改TLAB相关参数，推荐使用虚拟机默认行为。

- 根据 Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过 `-Xmx` 和 `-Xms` 控制）。

#### Java 堆会出现的异常

- 如果 Java 堆可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，那 Java 虚拟机将抛出一个 **OutOfMemoryError** 异常。

### 方法区

- 方法区(Method Area)与Java堆一样，是各个**线程共享**的内存区域，它用于存储已被虚拟机加载的`类型信息、常量、静态变量、即时编译器编译后的代码缓存`等数据。
- 对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选 择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集,这区域的内存回 收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收效果比较难令人满意，尤 其是类型的卸载，条件相当苛刻。

### 运行时常量池

- 运行时常量池是方法区中的一部分。常量池表是Class文件的一部分，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。
- 运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。
- JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据就像数组一样，通过索引访问的。
- 运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。
- 运行时常量池相对于Class文件的常量池的重要特征是：具有动态性，Java语言并不要求常量 一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常 量池，运行期间也可以将新的常量放入池中。（例：String.intern()）
- 运行时常量池类似于传统的编程语言中的符号表（symbol table），但是它所包含的数据比符号表更加丰富一些。
- 当创建类或者接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能承受的最大值。则 OOM。
  

### 直接内存

​		**直接内存(Direct Memory)并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中 定义的内存区域**。但是这部分内存也被频繁地使用，而且**也可能导致OutOfMemoryError异常出现**，所 以我们放到这里一起讲解。

​		在JDK 1.4中新加入了NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区 (Buffer)的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的 DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了 在J ava堆和Nat ive堆中来回复制数据。

​		显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到 本机总内存(包括物理内存、SWAP分区或者分页文件)大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得 各个内存区域总和大于物理内存限制(包括物理的和操作系统级的限制)，从而导致动态扩展时出现 OutOfMemoryError异常。