## 运行时数据区域

Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着`虚拟机进程`的启动而一直存在，有些区域则是依赖`用户线程`的启动和结束而建立和销毁。

![image-20220411135554948](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204111355026.png)

### 程序计数器

程序计数器(Program Counter Register)是一块`较小的内存空间`，它可以看作是当前线程所执行的字节码的`行号指示器`：

- Java方法：计数器记录的是正在执行的虚拟机字节码指令的地 址

- 本地方法：计数器值则应为空(U ndefined)

由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称`这类内存区域为线程私有的内存`。

此内存区域是唯 一一个在《Java虚拟机规范》中没有规定任何`OutOfMemoryError`情况的区域。

### Java虚拟机栈

虚拟机栈描述的是Java方法执行的线程`内存模型`:每个方法被执行的时候，Java虚拟机都会同步创建一个`栈帧`用于存储`局部变量表、操作数栈、动态连接、方法出口`等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

![image-20220411143532679](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204111435712.png)

- 栈帧存在于虚拟机栈中，并且是虚拟机栈中的单位元素
- **每个线程中的不同栈帧对应这个线程调用的不同方法**，可以看到栈帧很多，调用的方法链也会很多
- 在活动线程中，只有当前栈帧有效，与之对应的也就是当前正在执行的方法，此方法被成为当前方法
- 每调用一个新的方法，此方法对应的栈帧就会被放到栈顶（入栈），也就是成为新的当前栈帧；当一个方法退出的时候，此方法对应的栈帧也相应销毁（出栈）【递归的原理】

栈帧中需要多大的局部变量表，多深的操作数栈在编译成 .class 文件的时候都是已经确定好的，这些信息都存储在方法表中的 code 属性中，因此每个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响。

回顾一下方法表及 code 属性的定义。

- **方法表**：.class 文件中的方法表包含了此方法的一些信息：访问标志（public、private 等）、名称索引（指向常量池）、描述符索引（指向常量池，描述符用来描述方法的参数列表以及返回值）、属性表集合。
- **code 属性的定义**：code 属性存储在属性表中，而属性表是多种属性的集合。code 属性存放的就是经过编译器编译成字节码指令的 Java 方法里面的代码（里面记录了局部变量表的大小与操作数栈的深度）。

方法表中不一定需要属性表，因为如果这是一个抽象方法，那么这个方法生成的方法表中就不需要存在属性表（这个 Java 方法没有被定义，属性表中的其他属性也无法被生成）。

[局部变量表](https://github.com/zjmJavaByte/JavaQaaQ/blob/master/docs/jdk/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8.md)

**操作数栈**

**动态连接**

**方法出口**

### 本地方法栈

### Java堆

### 方法区

### 运行时常亮池

### 直接内存