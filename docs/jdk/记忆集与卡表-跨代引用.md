## 记忆集与卡表

### 为什么需要记忆集？

**跨代引用假说**

- 跨代引用相对于同代引用来说仅占极少数。

- 存在互相引用关系的两个对象，是应该倾向于同时生存或者同时消亡的。

> 举个例子，如果某个新生代对象存在跨代引用，由于老年代对象难以
> 消亡，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到老年代中，这时跨代引用也随即被消除了。

**记忆集(RememberedSet)作用**

​		**用以避免把整个老年代加进`GC Roots`扫描范围，缩减GC Roots扫描范围的问题**。事实上并不只是新生代、老年代之间才有跨代引用的问题，所有涉及部分区域收集(PartialGC)行为的垃圾收集器，典型的如G1、ZGC和Shenandoah收集器，都会面临相同的问题。

### 记忆集

​		**记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结**构

#### 数据结构的实现

**数据结构的精度**

- **字长精**度:每个记录精确到一个**机器字长**(就是处理器的寻址位数，如常见的32位或64位，这个 精度决定了机器访问物理内存地址的指针长度)，该字包含跨代指针。

- **对象精度**:每个记录精确到一个**对象**，该对象里有字段含有跨代指针。 
- **卡精度**:每个记录精确到一块**内存区域**，该区域内有对象含有跨代指针。

**数据结构的具体实现-卡表**

- 定义了记忆集的记录精度、与堆内存的映射关系

- HotSpot虚拟机的实现是一个字节数组

![image-20220415104304489](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204151043696.png)

​		字节数组CARD_TABLE的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作“**卡页**”(Card Page)。

​		![](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204151059835.jpg)

​		**一个卡页的内存中通常包含不止一个对象，只要卡页内有一个(或更多)对象的字段存在着跨代指**针，那就将对应卡表的数组元素的值标识为1，称为这个元素变脏(Dirty)，没有则标识为0。在垃 圾收集发生时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把它 们加入GC Roots中一并扫描。

#### 卡表的维护-写屏障

​		因为我们知道卡表记录了卡页里面的对象是否存在跨代引用，存在跨代引用数卡表就变脏了，这个**表脏的时间点原则上应该发生在引用类型字段赋值的那一刻**。但问题是如何变脏，即如何在对象赋值的那一刻去更新维护卡表呢?

解释执行：虚拟机负责每条字节码指令的执行，有充分的介入空间（**逐行将`.class`字节码转为机器码**）

编译执行：写屏障（**将热点代码一次编译成机器码，存储在方法区**）

##### 写屏障

​		**写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切面，在引用对象赋值时会产生一个环形(Around)通知，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内**

```c++
void oop_field_store(oop* field, oop new_value) { 
  // 引用字段赋值操作
	*field = new_value;
	// 写后屏障，在这里完成卡表状态更新 
  post_write_barrier(field, new_value);
}
```

##### 伪共享

​		**卡表在高并发场景下还面临着“伪共享”(False Sharing)问题**。伪共享是处 理并发底层细节时一种经常需要考虑的问题，现代中央处理器的缓存系统中是以缓存行(Cache Line) 为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影 响(写回、无效化或者同步)而导致性能降低，这就是伪共享问题。

​		假设处理器的缓存行大小为64字节，由于一个卡表元素占1个字节，64个卡表元素将共享同一个缓 存行。这64个卡表元素对应的卡页总的内存为32KB(64×512字节)，也就是说如果不同线程更新的对 象正好处于这32KB的内存区域内，就会导致更新卡表时正好写入同一个缓存行而影响性能。为了避免 伪共享问题，一种简单的解决方案是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏，即将卡表更新的逻辑变为以下代码所示:

```c++
if (CARD_TABLE [this address >> 9] != 0) 
  	CARD_TABLE [this address >> 9] = 0;
```

​		在JDK 7之后，HotSpot虚拟机增加了一个新的参数`-XX:+UseCondCardMark`，用来决定是否开启卡表更新的条件判断。开启会增加一次额外判断的开销，但能够避免伪共享问题，两者各有性能损 耗，是否打开要根据应用实际运行情况来进行测试权衡。