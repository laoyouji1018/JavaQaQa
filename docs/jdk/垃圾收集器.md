---
typora-copy-images-to: upload
---

# 常见的垃圾收集器

![image-20220415171953954](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204151719985.png)

# 经典垃圾收集器

## Serial

​		**这个收集器是一个单线程工作的收集器，但它的“单线 程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。**

![image-20220415153354539](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204151533577.png)

​		所有收集器里额外内存消耗(Memory Footprint)最小的

## ParNew

​		ParNew收集器实质上是Serial收集器的多线程**并行版本**，除了同时**使用多条线程进行垃圾收集**之 外，其余的行为包括Serial收集器可用的所有控制参数(例如:`-XX:SurvivorRat io、-XX: PretenureSizeThreshold、-XX:HandlePromotionFailure`等)、收集算法、`Stop The World`、对象分配规 则、回收策略等都与Serial收集器完全一致。

![image-20220415172656156](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204151726191.png)

- 目前只有它能与CM S 收集器配合工作
- ParNew收集器是激活CM S后(使用`-XX:+UseConcMarkSweepGC`选项)的默 认新生代收集器
- 它默认开启的收集线程数与处理器核心数量相同，在处理器核 心非常多(譬如32个，现在CPU都是多核加超线程设计，服务器达到或超过32个逻辑核心的情况非常 普遍)的环境中，可以使用`-XX:ParallelGCThreads`参数来限制垃圾收集的线程数。

> 并行(Parallel):并行描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线 程在协同工作，通常默认此时用户线程是处于等待状态。
>
> 并发(Concurrent):并发描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾 收集器线程与用户线程都在运行。

## Parallel Scavenge

​		新生代收集器、基于标记-复制算法实现的收集器、并行收集的多线程收集器，诸多特性从表面上看和ParNew非常相似，那它有什么特别之处呢?

​		**parallel Scavenge收集器的目标则是达到一个可控制的吞吐量(Throughput)，适用于后台运算不需要太多交互任务的分析任务。**

![image-20220418094142213](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204180941910.png)

**低延迟：**停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序，良 好的响应速度能提升用户体验

**高吞吐量：**高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算 任务，主要适合在后台运算而不需要太多交互的分析任务

​		Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量

> -XX:MaxGCPauseMillis ：控制最大垃圾收集停顿时间
>
> -XX:GCTimeRatio ：设置吞吐量大小

​		除上述两个参数之外，还有一个调节方式称为垃圾收集的**自适应的调节策略**(GC Ergonomics)，由参数`-XX:+UseAdaptiveSizePolicy`配置，当这个参数被激活之后，就不需要人工指定新生代的大小(-Xmn)、Eden与Survivor区 的比例(-XX:SurvivorRat io)、晋升老年代对象大小(-XX:Pret enureSiz eT hreshold)等细节参数 了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。

**参数配置**

| 参数 | 说明 |
| ---- | ---- |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |



## Serial Old

·	老年代版本、单线程收集器、标记-整理算法。

![image-20220418100345947](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204181003987.png)

## Parallel Old

​		老年代版本、多线程并发收集、基于标记-整理算法

![image-20220418100943392](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204181009412.png)

## CMS

- **低延迟**：CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器
- **基于标记-清除算法**

**收集过程**

- 初始标记：初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，暂停用户线程

- 并发标记：从GC Roots的直接关联对象开始遍历整个对 象图的过程

- 重新标记：修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（使用的是**增量更新**），暂停用户线程

- 并发清理：，清理删除掉标记阶段判断的已经死亡的 对象，**由于不需要移动存活对象**，所以这个阶段也是可以与用户线程同时并发的

![image-20220418110245192](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204181102235.png)

**CMS缺点**

- CMS收集器对处理器资源非常敏感，在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程(或者说处理器的计 算能力)而导致应用程序变慢，降低总吞吐量。
- CMS收集器无法处理“**浮动垃圾**”(FloatingGarbage)，有可能出现“Con-current Mode Failure”失败进而导致另一次完全“Stop The World”的Full GC的产生。
- 垃圾收集线程与用户线程是同时运行，所以要预留足够的空间给用户线程，可以通过参数`-XX:CMSInitiatingOccu-pancyFraction`来配置出发CMS的百分比，如果较低，内存回收灰太频繁，如果太改，预留的内存不够程序分配新对象的需要就会出现一次“并发失败”(Concurrent M ode Failure)，这时候虚拟机将不 得不启动后备预案:冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集， 但这样停顿时间就很长了
- CM S是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生，**在若干次GC之后，CMS必须执行一次碎片整理**

**配置参数**

| 参数                                | 说明                                                         |
| :---------------------------------- | ------------------------------------------------------------ |
| -XX:CMSInitiatingOccu-pancyFraction | CMS收集器当老年代使用了配置的空间后就会被激活                |
| -XX:+UseCMS-CompactAtFullCollection | 用于在CM S收集器不得不进行Full GC时开启内存碎片的合并整理过程（默认是开启的，此参数从 JDK 9开始废弃) |
| -XX:CM SFullGCsBefore- Compaction   | 要求CMS收集器在执行过若干次(数量 由参数值决定)不整理空间的Full GC之后，下一次进入Full GC前会先进行碎片整理(默认值为0，表示每次进入Full GC时都进行碎片整理，此参数从JDK 9开始废弃) |



## Garbage First



# 低延迟垃圾收集器

## Shenandoah

## ZGC

jdk11正式以实验性质加入的垃圾收集器

> ZGC的设计目标是：支持TB级内存容量，暂停时间低（<10ms），对整个程序吞吐量的影响小于15%。 将来还可以扩展实现机制，以支持不少令人兴奋的功能，例如多层堆（即热对象置于DRAM和冷对象置于NVMe闪存），或压缩堆。

### 主要特征

1、是一款基于`Region`内存布局的，（暂时）不设分带的

2、使用了`读屏障`、`染色指针`和`内存多重映射`技术

3、`并发标记-整理算法`的低延迟收集器

### 动态Region

> ZGC的region具有动态性，动态创建和销毁

ZGC的Region可以具有如图所示的大、中、小三类容量：

![](https://raw.githubusercontent.com/zjmJavaByte/images/master/images/java6-1615861320.png)

- 小型Region（Small Region）：容量固定为2MB，用于放置小于256KB的小对象。
- 中型Region（Medium Region）：容量固定为32MB，用于放置大于等于256KB但小于4MB的对象。·
- 大型Region（Large Region）：容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。每个大型Region中只会存放一个大对象，最小容量可低至4MB，所有大型Region可能小于中型Region。大型Region在ZGC的实现中是不会被重分配的，因为复制一个大对象的代价非常高昂。

`针对第三点：G1中把Java堆划分为多个大小相等的独立区域，所以如果某些超过了整个Region容器的超大对象，将会使用G1中一类特殊的Humongous Region，G1会将这些超大的对象放在多个Humongous Region中`

### 并发整理算法的实现

#### **染色指针**

###### **定义**

HotSpot虚拟机的标记实现方案有如下几种：

> 1. 把标记直接记录在对象头上（如Serial收集器）；
> 2. 把标记记录在与对象相互独立的数据结构上（如G1、Shenandoah使用了一种相当于堆内存的1/64大小的，称为BitMap的结构来记录标记信息）；
> 3. 直接把标记信息记在引用对象的指针上（如ZGC）

​		染色指针是一种直接将少量额外的信息存储在指针上的技术。目前在Linux下64位的操作系统中高18位是不能用来寻址的，但是剩余的46为却可以支持64T的空间，到目前为止我们几乎还用不到这么多内存。于是ZGC将46位中的高4位取出，用来存储4个标志位，剩余的42位可以支持4T的内存，如图所示：

![](https://raw.githubusercontent.com/zjmJavaByte/images/master/images/java4-1615861320.png)

- Linux下64位指针的高18位不能用来寻址，所有不能使用；
- Finalizable：表示是否只能通过finalize()方法才能被访问到，其他途径不行；
- Remapped：表示是否进入了重分配集（即被移动过）；
- Marked1、Marked0：表示对象的三色标记状态；
- 最后42用来存对象地址，最大支持4T；

###### 三色标记

在并发的可达性分析算法中我们使用三色标记（Tri-color Marking）来标记对象是否被收集器访问过：

- 白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。
- 黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。
- 灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。

可达性分析的扫描过程，其实就是一股以灰色为波峰的波纹从黑向白推进的过程，但是在并发的推进过程中会产生“对象消失”的问题，如图：

![](https://raw.githubusercontent.com/zjmJavaByte/images/master/images/java9-1615861321.png)

对象消失理论，只有同时满足才会发生对象消失：

- 赋值器插入了一条或多条从黑色对象到白色对象的新引用；
- 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用；

要解决对象消失问题只需要破坏其中一条就行了，目前常用有两种方案：

- 增量更新（Incremental Update）:增量更新要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。
- 原始快照（Snapshot At TheBeginning，SATB）:原始快照要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。

> 以上无论是对引用关系记录的插入还是删除，虚拟机的记录操作都是通过写屏障实现的。CMS是基于增量更新来做并发标记的，G1、Shenandoah则是用原始快照来实现。

###### **染色指针的三大优势**

1. 一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理，这使得理论上只要还有一个空闲Region，ZGC就能完成收集。而Shenandoah需要等到更新阶段结束才能释放回收集中的Region，如果Region里面对象都存活的时候，需要1:1的空间才能完成收集。
2. 染色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量，ZGC只使用了读屏障。
3. 染色指针具备强大的扩展性，它可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。

#### **读屏障**

​		当对象从堆中加载的时候，就会使用到读屏障（Load Barrier）。这里使用读屏障的主要作用就是检查指针上的三色标记位，根据标记位判断出对象是否被移动过，如果没有可以直接访问，如果移动过就需要进行“自愈”（对象访问会变慢，但也只会有一次变慢），当“自愈”完成后，后续访问就不会变慢了。

> 读写屏障可以理解成对象访问的“AOP”操作

#### 内存多重映射

> Java虚拟机作为一个普普通通的进程，这样随意的重新定义内存中某些指针的其中几位，操作系统是否支持？处理器是否支持？

​		ZGC使用了内存多重映射（Multi-Mapping）将多个不同的虚拟内存地址映射到同一个物理内存地址上，这是一种多对一映射，意味着ZGC在虚拟内存中看到的地址空间要比实际的堆内存容量来得更大。把染色指针中的标志位看作是地址的分段符，那只要将这些不同的地址段都映射到同一个物理内存空间，经过多重映射转换后，就可以使用染色指针正常进行寻址了，效果如图：

![](https://raw.githubusercontent.com/zjmJavaByte/images/master/images/java8-1615861321.png)

> ZGC的多重映射只是它采用染色指针技术的伴生产物

### ZGC运作过程

ZGC的运作过程大致可划分为以下四个大的阶段：

![【241期】面试官：你了解JVM中的ZGC垃圾收集器吗？](https://raw.githubusercontent.com/zjmJavaByte/images/master/images/java0-161511861321.png)

- 并发标记（Concurrent Mark）：与G1、Shenandoah一样，并发标记是遍历对象图做可达性分析的阶段，它的初始标记和最终标记也会出现短暂的停顿，整个标记阶段只会更新染色指针中的Marked 0、Marked 1标志位。
- 并发预备重分配（Concurrent Prepare for Relocate）：这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成重分配集（Relocation Set）。ZGC每次回收都会扫描所有的Region，用范围更大的扫描成本换取省去G1中记忆集的维护成本。
- 并发重分配（Concurrent Relocate）：重分配是ZGC执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表（Forward Table），记录从旧对象到新对象的转向关系。ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被预置的内存屏障所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为指针的“自愈”（Self-Healing）能力。

> ZGC的染色指针因为“自愈”（Self-Healing）能力，所以只有第一次访问旧对象会变慢，而Shenandoah的Brooks转发指针是每次都会变慢。一旦重分配集中某个Region的存活对象都复制完毕后，这个Region就可以立即释放用于新对象的分配，但是转发表还得留着不能释放掉，因为可能还有访问在使用这个转发表。

- 并发重映射（Concurrent Remap）：重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用，但是ZGC中对象引用存在“自愈”功能，所以这个重映射操作并不是很迫切。ZGC很巧妙地把并发重映射阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成，反正它们都是要遍历所有对象的，这样合并就节省了一次遍历对象图的开销。

### ZGC存在的问题

**浮动垃圾**

​		ZGC的停顿时间是在10ms以下，但是ZGC的执行时间还是远远大于这个时间的。假如ZGC全过程需要执行10分钟，在这个期间由于对象分配速率很高，将创建大量的新对象，这些对象很难进入当次GC，所以只能在下次GC的时候进行回收，这些只能等到下次GC才能回收的对象就是浮动垃圾。

> ZGC没有分代概念，每次都需要进行全堆扫描，导致一些“朝生夕死”的对象没能及时的被回收。

**解决方案**

​		目前唯一的办法是增大堆的容量，使得程序得到更多的喘息时间，但是这个也是一个治标不治本的方案。如果需要从根本上解决这个问题，还是需要引入分代收集，让新生对象都在一个专门的区域中创建，然后专门针对这个区域进行更频繁、更快的收集。

