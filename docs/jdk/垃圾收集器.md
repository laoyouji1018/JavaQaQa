# 常见的垃圾收集器

![image-20220415171953954](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204151719985.png)

# 经典垃圾收集器

## Serial

​		**这个收集器是一个单线程工作的收集器，但它的“单线 程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。**

![image-20220415153354539](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204151533577.png)

​		所有收集器里额外内存消耗(Memory Footprint)最小的

## ParNew

​		ParNew收集器实质上是Serial收集器的多线程**并行版本**，除了同时**使用多条线程进行垃圾收集**之 外，其余的行为包括Serial收集器可用的所有控制参数(例如:`-XX:SurvivorRat io、-XX: PretenureSizeThreshold、-XX:HandlePromotionFailure`等)、收集算法、`Stop The World`、对象分配规 则、回收策略等都与Serial收集器完全一致。

![image-20220415172656156](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204151726191.png)

- 目前只有它能与CM S 收集器配合工作
- ParNew收集器是激活CM S后(使用`-XX:+UseConcMarkSweepGC`选项)的默 认新生代收集器
- 它默认开启的收集线程数与处理器核心数量相同，在处理器核 心非常多(譬如32个，现在CPU都是多核加超线程设计，服务器达到或超过32个逻辑核心的情况非常 普遍)的环境中，可以使用`-XX:ParallelGCThreads`参数来限制垃圾收集的线程数。

> 并行(Parallel):并行描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线 程在协同工作，通常默认此时用户线程是处于等待状态。
>
> 并发(Concurrent):并发描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾 收集器线程与用户线程都在运行。

## Parallel Scavenge

​		新生代收集器、基于标记-复制算法实现的收集器、并行收集的多线程收集器，诸多特性从表面上看和ParNew非常相似，那它有什么特别之处呢?

​		**parallel Scavenge收集器的目标则是达到一个可控制的吞吐量(Throughput)，适用于后台运算不需要太多交互任务的分析任务。**

![image-20220418094142213](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204180941910.png)

**低延迟：**停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序，良 好的响应速度能提升用户体验

**高吞吐量：**高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算 任务，主要适合在后台运算而不需要太多交互的分析任务

​		Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量

> -XX:MaxGCPauseMillis ：控制最大垃圾收集停顿时间
>
> -XX:GCTimeRatio ：设置吞吐量大小

​		除上述两个参数之外，还有一个调节方式称为垃圾收集的**自适应的调节策略**(GC Ergonomics)，由参数`-XX:+UseAdaptiveSizePolicy`配置，当这个参数被激活之后，就不需要人工指定新生代的大小(-Xmn)、Eden与Survivor区 的比例(-XX:SurvivorRat io)、晋升老年代对象大小(-XX:Pret enureSiz eT hreshold)等细节参数 了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。

**参数配置**

| 参数                       | 说明                                                         |
| -------------------------- | ------------------------------------------------------------ |
| -XX:MaxGCPauseMillis       | 最大垃圾收集停顿时间                                         |
| -XX:GCTimeRatio            | 吞吐量大小,也就是垃圾收集时间占总时间的比率                  |
| -XX:+UseAdaptiveSizePolicy | 自适应的调节策略,当这个参数被激活之后，就不需要人工指定新生代的大小(-Xmn)、Eden与Survivor区 的比例(-XX:SurvivorRat io)、晋升老年代对象大小(-XX:Pret enureSiz eT hreshold)等细节参数 了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量 |

## Serial Old

·	老年代版本、单线程收集器、标记-整理算法。

![image-20220418100345947](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204181003987.png)

## Parallel Old

​		老年代版本、多线程并发收集、基于标记-整理算法

![image-20220418100943392](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204181009412.png)

## CMS

- **低延迟**：CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器
- **基于标记-清除算法**

**收集过程**

- 初始标记：初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，暂停用户线程

- 并发标记：从GC Roots的直接关联对象开始遍历整个对 象图的过程

- 重新标记：修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（使用的是**增量更新**），暂停用户线程

- 并发清理：，清理删除掉标记阶段判断的已经死亡的 对象，**由于不需要移动存活对象**，所以这个阶段也是可以与用户线程同时并发的

![image-20220418110245192](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204181102235.png)

**CMS缺点**

- CMS收集器对处理器资源非常敏感，在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程(或者说处理器的计 算能力)而导致应用程序变慢，降低总吞吐量。
- CMS收集器无法处理“**浮动垃圾**”(FloatingGarbage)，有可能出现“Concurrent Mode Failure”失败进而导致另一次完全“Stop The World”的Full GC的产生。
- 垃圾收集线程与用户线程是同时运行，所以要预留足够的空间给用户线程，可以通过参数`-XX:CMSInitiatingOccu-pancyFraction`来配置出发CMS的百分比，如果较低，内存回收灰太频繁，如果太高，预留的内存不够程序分配新对象的需要就会出现一次“并发失败”(Concurrent Mode Failure)，这时候虚拟机将不 得不启动后备预案:冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集， 但这样停顿时间就很长了
- CM S是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生，**在若干次GC之后，CMS必须执行一次碎片整理**

**配置参数**

| 参数                                | 说明                                                         |
| :---------------------------------- | ------------------------------------------------------------ |
| -XX:CMSInitiatingOccu-pancyFraction | CMS收集器当老年代使用了配置的空间后就会被激活                |
| -XX:+UseCMS-CompactAtFullCollection | 用于在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程（默认是开启的，此参数从 JDK 9开始废弃) |
| -XX:CM SFullGCsBefore- Compaction   | 要求CMS收集器在执行过若干次(数量 由参数值决定)不整理空间的Full GC之后，下一次进入Full GC前会先进行碎片整理(默认值为0，表示每次进入Full GC时都进行碎片整理，此参数从JDK 9开始废弃) |
| -XX:+UseConcM arkSweep GC           | 配置为CMS垃圾收集器（jdk5发布，jdk9不推荐使用）              |

## Garbage First

**特征**

- 收集器面向局部收集的设计思路和基于Region的内存布局形式
- 追求能够应付应用的内存分配速率 (Allocation Rate)，而不追求一次把整个Java堆全部清理干净
- G1是一款主要面向服务端应用的垃圾收集器
- **一款能够建立起“停顿时间模型”(Pause Prediction Model)的收集器**，停顿时间模型的意思是能够支持指定在一个长度为M毫秒的时间片段 内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标
- G1从整体来看是基于“标记-整理”算法实现的收集器，但从局部(两个Region 之间)上看又是基于“标记-复制”算法实现

**Region的内存布局**

- ***实现目标*：**指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标，既可预测的停顿时间模型

- ***一个思想*：**抛弃整个新生代、整个老年代或者整个堆作为回收对象，而是把连续的Java堆划分为多个大小相等的独立区域(Region)，每一个Region都可以，根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。每个Region的大小可以通过参数`-XX:G1HeapRegionSize`设定，取值范围为1M B~32M B，且应为2的N次幂

- ***回收衡量标准*：**不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大

- ***大对象特殊处理*：**G1认为只要大小超过了一个 Region容量一半的对象即可判定为大对象,而对于那些超过了整个Region容量的超级大对象， 将会被存放在N个连续的`Humongous Region`之中,这个区域被称为`Humongous`

![image-20220418151840648](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204181518727.png)

**Region的内存布局优点**

- **避免整个堆进行回收**，将`Region`作为单次回收的最小单元，即每次收集到的内存空间都是`Region`大小的整数倍
- **优先处理回收价值收益最大的那些`Region`**，通过后台维护一 个优先级列表，记录哪块`Region`回收收益最大

**待优化项**

- Region里面存在的跨Region引用对象

> 每个Region都维护有自己的记忆集，这些记忆集会记录下别的Region 指向自己的指针，并标记这些指针分别在哪些卡页的范围之内。G1的记忆集在存储结构的本质上是一 种哈希表，Key 是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号

- 并发标记阶段如何保证收集线程与用户线程互不干扰地运行

> *老对象消失*：通过原始快照(SATB)算法来避免存活的对象被回收
>
> *新对象分配*：G1为每一个Region设 计了两个名为TAMS(Top at Mark Start)的指针，把Region中的一部分空间划分出来用于并发回收过 程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上

- 怎样建立起可靠的停顿预测模型

> G1收集器的停顿预测模型是以`衰减均值(Decay ing Average)`为理论基础来实现的，在垃圾收集过程中，G1收集器会记录每个Region的回收耗时、每个Region记忆集里的脏卡数量等各个可测量的步骤花费的成本，并分析得 出平均值、标准偏差、置信度等统计信息，然后通过这些信息预测现在开始回收的话，由哪些Region组成回收集才可以在不超过期望停顿时间的约束下获得最高的收益。

**收集过程**

![image-20220418153929856](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204181539908.png)

- 初始标记：仅仅只是标记一下`GC Roots`能直接关联到的对象，并且修改`TAMS `指针的值。 *停顿线程，但耗时很短*

- 并发标记：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆 里的对象图，找出要回收的对象。 *与用户程序并发执行*

- 最终标记：处理`SATB`遗留下来的对象。*停顿线程，但耗时很短*

- 筛选回收：负责更新Region的统计数据，对各个Region的回 收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region 构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧 Region的全部空间。*暂停用户线程*

**设置符合实际的期望停顿值**

- 默认为200毫秒

- 建议范围设在一两百毫秒或者两三百毫秒会是比较合理

**CMS与G1收集器的比较**

空间碎片：

> CMS：标记-清除
>
> G1：整体时标记--整理，局部标记复制

内存占用：

> CMS：卡表只有一份，而且只需要处理老年代到新生代的引用，反过来则不需要
>
> G1:每个Region维护一份

执行负载：

> CMS：用写后屏障来更新维护卡表
>
> G1：使用写后屏障来进行 同样的(由于G1的卡表结构复杂，其实是更烦琐的)卡表维护操作外、使用写前屏障来跟踪并发时的指针变化情况

Stop The World:

> CSM：大量的浮动垃圾（基于标记清理算法）、通过参数`-XX:CMSInitiatingOccu-pancyFraction`来配置预留的内存太低
>
> G1：内存回收的速度赶不上分配的速度

**G1的卡表设计**

​		每个`Region`又被分成了若干个大小为`512`字节的`Card`，这些Card都会记录在全局卡表中。`Card`中的每个元素对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称为卡页。一个卡页的内存中通常不止一个对象，只有卡页中有一个及以上对象的字段存在着跨`Region`引用，这个对应的元素的值就标识为`1`。比如`G1`默认的`Region`有`2048`个，默认每个`Region`为`2M`，那每个`Region`对应的`Card`的每个元素对应的卡页的大小为`2M / 512=4`K，即这`4K`内存中只要有一个或一个以上的对象存在着跨`Region`对年轻代的引用，这个卡页对应的`Card`的元素值为1。

![image-20220418152209335](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204181522377.png)

​		这样在Minor GC时，只需要将变脏的Region中的那个卡页加入GC Roots一并扫描即可。比起扫描老年代的所有对象，大大减少了扫描的数据量，提升了效率。

# 低延迟垃圾收集器

## Shenandoah



## ZGC

jdk11正式以实验性质加入的垃圾收集器

> ZGC的设计目标是：支持TB级内存容量，暂停时间低（<10ms），对整个程序吞吐量的影响小于15%。 将来还可以扩展实现机制，以支持不少令人兴奋的功能，例如多层堆（即热对象置于DRAM和冷对象置于NVMe闪存），或压缩堆。

### 主要特征

1、是一款基于`Region`内存布局的，（暂时）不设分带的

2、使用了`读屏障`、`染色指针`和`内存多重映射`技术

3、`并发标记-整理算法`的低延迟收集器

### 动态Region

> ZGC的region具有动态性，动态创建和销毁

ZGC的Region可以具有如图所示的大、中、小三类容量：

![](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204181707377.png)

- 小型Region（Small Region）：容量固定为2MB，用于放置小于256KB的小对象。
- 中型Region（Medium Region）：容量固定为32MB，用于放置大于等于256KB但小于4MB的对象。·
- 大型Region（Large Region）：容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。每个大型Region中只会存放一个大对象，最小容量可低至4MB，所有大型Region可能小于中型Region。大型Region在ZGC的实现中是不会被重分配的，因为复制一个大对象的代价非常高昂。

`针对第三点：G1中把Java堆划分为多个大小相等的独立区域，所以如果某些超过了整个Region容器的超大对象，将会使用G1中一类特殊的Humongous Region，G1会将这些超大的对象放在多个Humongous Region中`

### 并发整理算法的实现

#### **染色指针**

###### **定义**

HotSpot虚拟机的标记实现方案有如下几种：

> 1. 把标记直接记录在对象头上（如Serial收集器）；
> 2. 把标记记录在与对象相互独立的数据结构上（如G1、Shenandoah使用了一种相当于堆内存的1/64大小的，称为BitMap的结构来记录标记信息）；
> 3. 直接把标记信息记在引用对象的指针上（如ZGC）

​		染色指针是一种直接将少量额外的信息存储在指针上的技术。目前在Linux下64位的操作系统中高18位是不能用来寻址的，但是剩余的46为却可以支持64T的空间，到目前为止我们几乎还用不到这么多内存。于是ZGC将46位中的高4位取出，用来存储4个标志位，剩余的42位可以支持4T的内存，如图所示：

![](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204181707949.png)

- Linux下64位指针的高18位不能用来寻址，所有不能使用；
- Finalizable：表示是否只能通过finalize()方法才能被访问到，其他途径不行；
- Remapped：表示是否进入了重分配集（即被移动过）；
- Marked1、Marked0：表示对象的三色标记状态；
- 最后42用来存对象地址，最大支持4T；

###### 三色标记

在并发的可达性分析算法中我们使用三色标记（Tri-color Marking）来标记对象是否被收集器访问过：

- 白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。
- 黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。
- 灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。

可达性分析的扫描过程，其实就是一股以灰色为波峰的波纹从黑向白推进的过程，但是在并发的推进过程中会产生“对象消失”的问题，如图：

![](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204181707365.png)

对象消失理论，只有同时满足才会发生对象消失：

- 赋值器插入了一条或多条从黑色对象到白色对象的新引用；
- 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用；

要解决对象消失问题只需要破坏其中一条就行了，目前常用有两种方案：

- 增量更新（Incremental Update）:增量更新要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。
- 原始快照（Snapshot At TheBeginning，SATB）:原始快照要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。

> 以上无论是对引用关系记录的插入还是删除，虚拟机的记录操作都是通过写屏障实现的。CMS是基于增量更新来做并发标记的，G1、Shenandoah则是用原始快照来实现。

###### **染色指针的三大优势**

1. 一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理，这使得理论上只要还有一个空闲Region，ZGC就能完成收集。而Shenandoah需要等到更新阶段结束才能释放回收集中的Region，如果Region里面对象都存活的时候，需要1:1的空间才能完成收集。
2. 染色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量，ZGC只使用了读屏障。
3. 染色指针具备强大的扩展性，它可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。

#### **读屏障**

​		当对象从堆中加载的时候，就会使用到读屏障（Load Barrier）。这里使用读屏障的主要作用就是检查指针上的三色标记位，根据标记位判断出对象是否被移动过，如果没有可以直接访问，如果移动过就需要进行“自愈”（对象访问会变慢，但也只会有一次变慢），当“自愈”完成后，后续访问就不会变慢了。

> 读写屏障可以理解成对象访问的“AOP”操作

#### 内存多重映射

> Java虚拟机作为一个普普通通的进程，这样随意的重新定义内存中某些指针的其中几位，操作系统是否支持？处理器是否支持？

​		ZGC使用了内存多重映射（Multi-Mapping）将多个不同的虚拟内存地址映射到同一个物理内存地址上，这是一种多对一映射，意味着ZGC在虚拟内存中看到的地址空间要比实际的堆内存容量来得更大。把染色指针中的标志位看作是地址的分段符，那只要将这些不同的地址段都映射到同一个物理内存空间，经过多重映射转换后，就可以使用染色指针正常进行寻址了，效果如图：

![](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204181707813.png)

> ZGC的多重映射只是它采用染色指针技术的伴生产物

### ZGC运作过程

ZGC的运作过程大致可划分为以下四个大的阶段：

![【241期】面试官：你了解JVM中的ZGC垃圾收集器吗？](https://cdn.jsdelivr.net/gh/zjmJavaByte/images/img/202204181708178.png)

- 并发标记（Concurrent Mark）：与G1、Shenandoah一样，并发标记是遍历对象图做可达性分析的阶段，它的初始标记和最终标记也会出现短暂的停顿，整个标记阶段只会更新染色指针中的Marked 0、Marked 1标志位。
- 并发预备重分配（Concurrent Prepare for Relocate）：这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成重分配集（Relocation Set）。ZGC每次回收都会扫描所有的Region，用范围更大的扫描成本换取省去G1中记忆集的维护成本。
- 并发重分配（Concurrent Relocate）：重分配是ZGC执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表（Forward Table），记录从旧对象到新对象的转向关系。ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被预置的内存屏障所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为指针的“自愈”（Self-Healing）能力。

> ZGC的染色指针因为“自愈”（Self-Healing）能力，所以只有第一次访问旧对象会变慢，而Shenandoah的Brooks转发指针是每次都会变慢。一旦重分配集中某个Region的存活对象都复制完毕后，这个Region就可以立即释放用于新对象的分配，但是转发表还得留着不能释放掉，因为可能还有访问在使用这个转发表。

- 并发重映射（Concurrent Remap）：重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用，但是ZGC中对象引用存在“自愈”功能，所以这个重映射操作并不是很迫切。ZGC很巧妙地把并发重映射阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成，反正它们都是要遍历所有对象的，这样合并就节省了一次遍历对象图的开销。

### ZGC存在的问题

**浮动垃圾**

​		ZGC的停顿时间是在10ms以下，但是ZGC的执行时间还是远远大于这个时间的。假如ZGC全过程需要执行10分钟，在这个期间由于对象分配速率很高，将创建大量的新对象，这些对象很难进入当次GC，所以只能在下次GC的时候进行回收，这些只能等到下次GC才能回收的对象就是浮动垃圾。

> ZGC没有分代概念，每次都需要进行全堆扫描，导致一些“朝生夕死”的对象没能及时的被回收。

**解决方案**

​		目前唯一的办法是增大堆的容量，使得程序得到更多的喘息时间，但是这个也是一个治标不治本的方案。如果需要从根本上解决这个问题，还是需要引入分代收集，让新生对象都在一个专门的区域中创建，然后专门针对这个区域进行更频繁、更快的收集。

## 选择合适的垃圾收集器

​		HotSpot虚拟机提供了种类繁多的垃圾收集器，选择太多反而令人踌躇难决，若只挑最先进的显然 不可能满足全部应用场景，但只用一句“必须因地制宜，按需选用”

我们应该如何选择一款适合自己应用的收集器呢?这个问题的答案主要受以下三 个因素影响:

- 应用程序的主要关注点是什么?如果是数据分析、科学计算类的任务，目标是能尽快算出结果， 那吞吐量就是主要关注点;如果是SLA应用，那停顿时间直接影响服务质量，严重的甚至会导致事务 超时，这样延迟就是主要关注点;而如果是客户端应用或者嵌入式应用，那垃圾收集的内存占用则是 不可忽视的。

- 运行应用的基础设施如何?譬如硬件规格，要涉及的系统架构是x86-32/64、SPARC还是
   ARM /Aarch64;处理器的数量多少，分配内存的大小;选择的操作系统是Linux、Solaris还是Windows 等。

- 使用JDK的发行商是什么?版本号是多少?是ZingJDK/Zulu、OracleJDK、Open-JDK、OpenJ9抑 或是其他公司的发行版?该JDK对应了《Java虚拟机规范》的哪个版本?

**举例**

> - 如果你有充足的预算但没有太多调优经验，那么一套带商业技术支持的专有硬件或者软件解决方 案是不错的选择，Azul公司以前主推的Vega系统和现在主推的Zing VM是这方面的代表，这样你就可以 使用传说中的C4收集器了。
>
> - 如果你虽然没有足够预算去使用商业解决方案，但能够掌控软硬件型号，使用较新的版本，同时 又特别注重延迟，那ZGC很值得尝试。
>
> - 如果你对还处于实验状态的收集器的稳定性有所顾虑，或者应用必须运行在Win-dows操作系统 下，那Z G C就无缘了，试试Shenandoah吧。
>
> - 如果你接手的是遗留系统，软硬件基础设施和JDK版本都比较落后，那就根据内存规模衡量一 下，对于大概4GB到6GB以下的堆内存，CM S一般能处理得比较好，而对于更大的堆内存，可重点考 察一下G1。

## 垃圾收集器日志
