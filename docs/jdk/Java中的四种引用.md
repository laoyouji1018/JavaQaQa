		我们知道判断一个对象是否还存活可以通过`引用计数算法`或者`可达性算法`进行判断，无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否引用链可达，判定对象是否存活都和“引用”离不开关系。

​		为了高效的利用内存和回收内存，Java对引用的概念进行了扩充，将引用分为强引用(Strongly Re-ference)、软引用(Soft Reference)、弱引用(Weak Reference)和虚引用(Phantom Reference)4种，这4种引用强 度依次逐渐减弱。**在这种分类下，当内存空间还足够时，能保留在内存之中，如果内存空间在进行垃圾收集后仍然非常紧张，那就可以抛弃这些对象。**

#### 强引用

- 使用最普遍的引用。
- 只要引用链没有断开，强引用就不会断开。- 当内存空间不足，抛出`OutOfMemoryError`终止程序也不会回收具有强引用的对象。
- 通过将对象设置为null来弱化引用,使其被回收

```java
Object obj=new Object()
```

#### 软引用

- 对象处在有用但非必须的状态
- 只有当内存空间不足时, GC会回收该引用的对象的内存。
- 可以用来实现高速缓存（作用）--比如网页缓存、图片缓存

```java
// 注意：wrf这个引用也是强引用，它是指向SoftReference这个对象的，
// 这里的软引用指的是指向new String("str")的引用，也就是SoftReference类中T
SoftReference<String> wrf = new SoftReference<String>(new String("str"));
```

#### 弱引用

- 非必须的对象,比软引用更弱一些
- GC时会被回收
- 被回收的概率也不大,因为GC线程优先级比较低
- 适用于引用偶尔被使用且不影响垃圾收集的对象使用

```java
//WeakHashMap 里的entry可能会被GC自动删除，即使没有主动调用 remove() 或者 clear() 方法
Map<String, String> activeEngineResources = new WeakHashMap<>();
```

#### 虚引用

​		虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的 存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。**为一个对象设置虚 引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。**